
```python
class Animal:
    def breathe(self):
        print("Breathing")

class Dog(Animal):
    def bark(self):
        print("Barking")

class Puppy(Dog):
    def weep(self):
        print("Weeping")

p = Puppy()
p.breathe()
p.bark()
p.weep()
#  Multiple Inheritance in Python

##  What is Multiple Inheritance?
Multiple inheritance is a feature in object-oriented programming where a **child class** can inherit attributes and methods from **more than one parent class**.

> Example: If `Child` inherits from both `Parent1` and `Parent2`, it gains access to both of their properties and methods.

---

##  Syntax
```python
class Parent1:
    # Parent1 members

class Parent2:
    # Parent2 members

class Child(Parent1, Parent2):
    # Child members
```

---

##  Why Use Multiple Inheritance?
- **Code Reusability** – Write once, use in multiple places.
- **Combining Features** – Merge functionalities from different classes.
- **Organized Design** – Keep related features in separate classes.

---

##  Basic Example
```python
class Engine:
    def start_engine(self):
        print("Engine started.")

class MusicSystem:
    def play_music(self):
        print("Playing music...")

class Car(Engine, MusicSystem):
    def drive(self):
        print("Car is moving.")

# Usage
my_car = Car()
my_car.start_engine()   # From Engine
my_car.play_music()     # From MusicSystem
my_car.drive()          # From Car
```

**Output:**
```
Engine started.
Playing music...
Car is moving.
```

---

##   Real-Life Analogy
Think of a **Smartphone**:
- It’s a **Phone** (can make calls)  
- It’s a **Camera** (can take pictures)  
- It’s a **Music Player** (can play music)  

A smartphone **inherits** features from all these categories.

---

##  Method Resolution Order (MRO)
When multiple parents have methods with the same name, Python decides **which one to use first** using **MRO**.

### Example:
```python
class A:
    def show(self):
        print("From A")

class B:
    def show(self):
        print("From B")

class C(A, B):
    pass

obj = C()
obj.show()  # Output: From A
print(C.mro())  # Method Resolution Order
```

**Output:**
```
From A
[<class '__main__.C'>, <class '__main__.A'>, <class '__main__.B'>, <class 'object'>]
```

---

##  Diamond Problem
The **diamond problem** occurs when two parent classes inherit from the same base class and the child inherits from both parents.  
This can cause **ambiguity** in method calls.

### Diagram
```
    A
   / \
  B   C
   \ /
    D
```

### Example:
```python
class A:
    def show(self):
        print("A called")

class B(A):
    def show(self):
        print("B called")

class C(A):
    def show(self):
        print("C called")

class D(B, C):
    pass

d = D()
d.show()         # Output: B called
print(D.mro())   # MRO order
```

**Output:**
```
B called
[<class '__main__.D'>, <class '__main__.B'>, <class '__main__.C'>, <class '__main__.A'>, <class 'object'>]
```

---

##  Multiple Inheritance Diagram
```
   Parent1        Parent2
      \             /
       \           /
        \         /
          Child
```

---

##  Best Practices
- Use **multiple inheritance** **only when necessary**.
- Keep parent classes **focused on one responsibility**.
- Always check **MRO** when method names may overlap.
- Consider using **composition** instead of inheritance when possible.

---

##  Conclusion
Multiple inheritance is a **powerful** tool in Python that allows combining functionalities from multiple parent classes.  
However, **misuse can lead to complexity and ambiguity** — use it **wisely**.

---

**Author:** :KARTHIK LU  
**Date:** :2025-08-11  

